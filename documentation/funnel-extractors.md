# Funnel Extractors: Turning Generic Events into Funnel Outcomes (with Expiry and Overrides)

Obsinity treats all incoming data as generic events. Funnel behavior (started, completed, abandoned, timed out) is derived from those events via configuration. This document explains how funnel extraction works and why it follows the same design pattern as State Extractors.

## Core Idea

- Events are the primitive.
- Funnels are derived, not special-cased.
- Configuration defines how to interpret events as funnel lifecycle signals.
- The same event stream can drive multiple funnels, multiple instances, and multiple derived views without changing producers or ingest pipelines.

This is a deliberate system-wide pattern in Obsinity.

## What a Funnel Means in Obsinity

A funnel represents a process instance identified by:

- funnelName (configured)
- processKey (derived from event attributes)

Each funnel instance:

- has a derived start
- may receive activity
- ends in exactly one terminal outcome
- may expire automatically
- may later be corrected if a late completion arrives

Funnel extraction produces derived counters, not new event types.

## Funnel Lifecycle Model

### Funnel instance state

Internally, Obsinity tracks:

- start_ts
- expiry_ts (derived, not event-supplied)
- final_status (nullable)
- finalized_ts
- outcome_version (increments on override)

### Terminal outcomes

A funnel instance can end via:

1. Completion (derived from a generic event)
2. Expiry (auto-generated by policy)

Expiry is not permanent if override is enabled.

## How Funnel Extraction Works

Funnel extraction is configured per service and event name, just like state extractors.

When an event arrives:

1. Obsinity looks up funnel extractors matching the event name.
2. For each extractor:

- It derives the processKey from configured attribute paths.
- If the key is missing or blank, the extractor is skipped.
- It evaluates configured rules:

- start
- activity (optional)
- complete

- It updates internal funnel instance state.
- If a terminal outcome is produced or corrected, Obsinity emits derived counter deltas.

## Start Is Derived

There is no special start event.

A funnel starts when an event matches the configured start predicate, or when a configured first-seen rule applies.

Only the first matching event per instance establishes start_ts.

## Completion Is Derived

There is no special completion event.

A funnel completes when an event matches the configured completion predicate, and a status mapping determines the resulting outcome status.

Completion may happen:

- before expiry (normal)
- after expiry (override, if enabled)

## Expiry Is Derived and Configured

Expiry is not supplied by events.

Instead, expiry is derived using a configured policy.

### Expiry policies

Supported modes:

- FIXED_TTL_FROM_START

- expiry_ts = start_ts + ttl

- IDLE_TTL_FROM_LAST_ACTIVITY

- expiry_ts = last_seen_ts + idleTtl

- HYBRID

- fixed TTL with optional activity-based extension

### Configured expiry status

Expiry does not imply a hard-coded status like EXPIRED.

Each funnel defines its own expiry outcome:

```yaml
expiry:
  ttl: PT30M
  status: ABANDONED
```

This status is treated exactly like any completion status.

## Late Completion Override Model

Obsinity supports post-expiry completion correction to keep ratios accurate.

### Policy

```yaml
expiry:
  lateCompletion: OVERRIDE
```

### Behavior

If a funnel expires:

- increment expiry.status +1 at expiry_ts

If a completion arrives after expiry:

- decrement expiry.status -1 at expiry_ts
- increment <completionStatus> +1 at completion_ts

This ensures:

- historical buckets are corrected
- ratios are accurate for any query window
- no hidden netting logic is required at query time

## Derived Counter Deltas (Key Concept)

Funnels emit deltas, not absolute counts.

Each terminal or corrective action produces one or more deltas:

| Scenario | Emitted deltas |
| --- | --- |
| Normal completion | STATUS +1 @ completion_ts |
| Expiry | expiry.status +1 @ expiry_ts |
| Late completion override | expiry.status -1 @ expiry_ts; STATUS +1 @ completion_ts |

Rollups are computed as sums of deltas.

Negative deltas are expected and supported.

## Example Configuration

```yaml
service: payments

funnelExtractors:
  - funnelName: checkout

    rawTypes:
      - checkout.viewed
      - cart.updated
      - checkout.completed
      - checkout.cancelled

    processKey:
      objectType: CheckoutSession
      objectIdField: checkout.session_id

    start:
      whenRawTypeIn: [checkout.viewed, cart.updated]
      startTsField: meta.ts

    activity:
      whenRawTypeIn: [cart.updated]
      activityTsField: meta.ts

    complete:
      whenRawTypeIn: [checkout.completed, checkout.cancelled]
      status:
        mapByRawType:
          checkout.completed: COMPLETED
          checkout.cancelled: CANCELLED
      completeTsField: meta.ts

    expiry:
      mode: FIXED_TTL_FROM_START
      ttl: PT30M
      status: ABANDONED
      lateCompletion: OVERRIDE
```

### What this means

- Checkout funnel starts on view or cart update.
- Activity extends expiry if configured.
- Completion status is derived from event type.
- If no completion within 30 minutes -> ABANDONED.
- If a completion arrives later -> abandoned count is repaired and success is counted.

## Multiple Funnels Per Event

A single event may drive:

- multiple funnel extractors
- multiple funnel instances
- state extractors
- counters and histograms

Each extractor operates independently and only if its attribute paths exist.

This mirrors the multiple object types per event behavior of state extractors.

## Multiple Instances and Restarts

Instances are identified by:

```
(funnelName, processKey, generation)
```

Generation increments when:

- a new start arrives after finalization, or
- a configured reset rule matches

This allows:

- repeated funnels for the same key
- cyclical business processes

## Derived Metrics

From funnel deltas, Obsinity can produce:

- Funnel started counts
- Funnel outcome counts by status
- Conversion rates
- Drop-off or abandonment rates
- Time-windowed funnel analytics

All without changing event schemas.

## Operational Notes

- If processKey is missing or blank, the extractor does nothing.
- If an event name has no funnel extractor configuration, it is treated as a normal event only.
- Funnel extraction runs during ingest, with a lightweight expiry job.
- Rollups must support late and negative deltas.
- Idempotency is mandatory for deltas (deterministic IDs).
- AI-generated logic requires human review, strong tests, and validation.

## Why This Pattern Matters

Obsinity intentionally layers meaning on top of generic events:

- Generic events -> state updates
- Generic events -> transitions
- Generic events -> funnels
- Generic events -> counters and histograms

This avoids schema coupling, keeps producers simple, and allows new analytics features to be added purely by configuration.

It is a core design principle of Obsinity.

## Related Files (Illustrative)

- .../service-definitions/services/<service>/state-extractors.yaml
- .../service-definitions/services/<service>/funnel-extractors.yaml
- StateDetectionService
- FunnelDetectionService
- FunnelExpiryJob
