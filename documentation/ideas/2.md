# Goal

Provide fast, reliable lists of known values for selected **indexed attributes** (e.g., `env`, `region`, `metric.name`, `partner_id`) to power filters, autosuggest, and guardrails in UIs and derivations.

---

# Scope & identity

Decide the scoping keys up front (pick what you’ll filter by most):

* **Minimum**: `attr_key`, `attr_value`
* Often useful: `service_id`, `event_type`
* Optional: `version` of the event schema (if you evolve meanings over time)

Keep a small registry of “tracked attributes,” e.g.:

* `event_indexed_attributes(attr_key, is_tracked, notes …)`

---

# Options (from simplest to most robust)

## 1) On-demand DISTINCT (no storage)

**What:** Query `SELECT DISTINCT attributes->>'region' FROM events_raw WHERE …` when needed.
**Pros:** Zero maintenance; always fresh.
**Cons:** Slow/expensive at scale; repeated work; poor UX under load.
**Use when:** Low volume, prototypes, admin tools.

---

## 2) Materialized views (MV) per attribute or per event

**What:** `CREATE MATERIALIZED VIEW` that precomputes distincts; `REFRESH` on a schedule.
**Pros:** Fast reads; simple to operate.
**Cons:** Refresh is bulk (locks view briefly); not truly incremental.
**Use when:** Moderate volume + predictable refresh cadence (e.g., every minute).

---

## 3) Dictionary tables with periodic batch upserts ✅ (recommended default)

**What:** A table like `attribute_values(attr_key, attr_value, service_id?, event_type?, first_seen, last_seen, occurrence)` maintained by a small job that scans the **recent window** (e.g., last 60 min) and **upserts**.
**Pros:** Cheap incremental cost; fast reads; easy to expire; preserves counts & “last seen.”
**Cons:** Slight staleness between runs; needs a tiny scheduler.
**Use when:** Most teams—good balance of simplicity and performance.

---

## 4) Ingestion-path write-through dictionary (app-level)

**What:** During ingest, application extracts tracked attributes and upserts into the dictionary immediately.
**Pros:** Near-real-time distincts; no extra cron.
**Cons:** Adds write amplification on ingest path; careful with hot keys & retries; avoid triggers.
**Use when:** You need distincts to be live within seconds and can afford extra writes.

---

## 5) Windowed dictionaries (time-scoped)

**What:** Keep “last N days” distincts in rolling tables (e.g., `attribute_values_7d`), purge older.
**Pros:** Reflects current reality; bounded storage; stable UI lists.
**Cons:** Loses historical rare values outside the window.
**Use when:** You only care about *recent* values (most dashboards).

---

## 6) Approximate cardinality / Top-K for very high-cardinality fields

**What:** Maintain **HyperLogLog** sketches for cardinality and a **Top-K** structure (e.g., Count-Min Sketch + heap) for most frequent values; optionally backfill exacts for the top set only.
**Pros:** Handles huge domains cheaply; fast UI experiences.
**Cons:** Approximate; long tail not enumerated.
**Use when:** Attributes like `user_id`, `request_id`, or `url` explode in size—show top values + search instead of full lists.

---

## 7) External cache (Redis) as a read-through mirror

**What:** Mirror distinct lists to Redis sets/Sorted Sets; repopulate from the DB job.
**Pros:** Ultra-fast UI; low DB pressure.
**Cons:** Extra moving part; cache invalidation strategy.
**Use when:** High-traffic filter UIs or autocompletes.

---

## 8) Enums / reference tables for bounded attributes

**What:** For truly bounded domains (`env`, `region`, `status`), manage a small **reference table or enum** and validate at ingest.
**Pros:** Clean data; instant lists.
**Cons:** Needs governance to update values.
**Use when:** The set is intentionally controlled.

---

# Operational tips

* **Track what you care about:** Only manage distincts for attributes listed in `event_indexed_attributes`.
* **Scope wisely:** Many UIs want `attr_value` **per service** or **per event\_type**; store those columns if you’ll filter by them.
* **Retention:** Add `first_seen`/`last_seen` and purge values not seen in, say, 30–90 days (configurable).
* **Cardinality guardrails:** If an attribute’s set explodes, switch it to **Top-K** mode or require a **prefix search** instead of full enumeration.
* **Privacy/masking:** Respect your masking rules—never surface masked/PII attributes in dictionaries.
* **Partition-aware:** If `events_raw` is partitioned weekly, your batch job should scan only **recent partitions**.
* **Backfill:** Provide a one-off backfill job to seed dictionaries from historical data during rollout.

---

# Choosing a path (quick guide)

* **Small/medium volume, need fast UI lists:** **Option 3** (dictionary table + periodic upsert).
* **Need sub-minute freshness:** Option 4 (ingest write-through) or Option 3 with 30–60s cadence.
* **Very high cardinality:** Option 6 (Approx + Top-K) for the heavy attributes; Option 3 for the rest.
* **Bounded domains:** Option 8 (reference tables/enums).
* **High-traffic UIs:** Layer **Option 7** (Redis cache) on top of your chosen store.

---
