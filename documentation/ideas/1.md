## Final intrinsic event kinds

1. **gauge** — first-class (min/max/last/avg/count)
2. **generic** — catch-all business/domain events (immutable, includes audits & logs)
3. **state** — discrete status/transition (optionally powers activeness/health UIs)

That’s it. Everything else (counters, histograms, latency percentiles, error rates, etc.) is **derived** from these.

---

## Attribute conventions (so queries & derivations stay predictable)

### gauge

* Required:

    * `metric.kind` = `"gauge"`
    * `metric.name` (e.g., `cpu.load`)
    * `gauge.min`, `gauge.max`, `gauge.last`, `gauge.avg`, `gauge.count`
* Optional:

    * `metric.unit` (`percent`, `bytes`, `ms`, …)
    * Dimensions you want indexed: `env`, `region`, `host`, `node_id`, `service.instance`, …

### generic

* Required: nothing beyond your business schema
* Patterns to standardize (so derivations are easy):

    * **Audits**: `actor.id`, `action`, `resource.type`, `resource.id`, `outcome`
    * **Logs**: `log.level`, `log.message`, `log.logger`, `exception.type`, `exception.message`
    * **Latency-bearing ops**: `duration.ms` (lets you derive histograms/percentiles)
    * **Success/failure**: `status` in `{success,failed,timeout,skipped}`, plus `error.code`

### state

* Required:

    * `state.name` (e.g., `connection`, `node.health`)
    * `state.value` (e.g., `active|inactive`, `healthy|degraded|down`)
* Optional:

    * `prev_value`, `reason`, `ttl.seconds` (if it should auto-expire in UI)

> Note: You can drive “active nodes” either from **any** events that carry `node_id`, or by emitting an explicit `state` event (`state.name="node.health"`, `state.value="alive"`). Most teams just rely on “any event in last N minutes” to mark nodes active, which you’ve already got.

---

## Gauge rollups (basic logic)

When aggregating gauges from a finer to a coarser granularity (e.g., 5s → 1m → 1h):

* **min** → take the minimum of all child mins
* **max** → take the maximum of all child maxes
* **last** → carry forward the last value from the chronologically latest child
* **count** → sum of all child counts
* **avg** → weighted average:

  $$
  avg\_parent = \frac{Σ(avg\_child × count\_child)}{Σ(count\_child)}
  $$

This preserves both the distribution (min/max), the latest observed value (last), and the central tendency (avg).

---

## Derived metrics mapping (examples)

* **Counters** (derived from `generic` or `state`)

    * Count payments: `event_type='payment'` → counter `payments.total`
    * Count errors: `status='failed'` → counter `errors.total`

* **Histograms** (derived from `generic`)

    * Latency: bucket `duration.ms` for `api.request` → `api.latency.ms` histogram

* **Rates/SLIs**

    * Success rate = success\_count / total\_count per bucket
    * p95 latency from histogram per bucket

Rollups: counters/histos sum; gauges do min/max/last/weighted-avg.

---

## TL;DR

* Minimal, orthogonal, and future-proof: **gauge**, **generic**, **state**.
* Derive counters/histograms/SLIs from those.
* Gauges roll up with **min/max/last/weighted-avg** rules.
* Use enums to keep your corpus clean; use attribute conventions to keep derivations simple.
* “Active nodes” stays an app/query concern using `node_id` + recency.

---
